#include <iostream>
#include <vector>
#include <unordered_map>
#include <functional>
#include <unistd.h>
#include <sys/select.h>
#include <pthread.h>

#define MAX_FDS 1024

using handler_t = std::function<void(int)>;
extern "C"{
struct FdHandler {
    int fd;
    handler_t handler;
};

struct Reactor {
    bool active;
    std::vector<FdHandler> fds;
    int max_fd;
    fd_set read_fds;
    pthread_t thread;
};

    Reactor* createReactor() {
        Reactor* reactor = new Reactor();
        reactor->active = false;
        reactor->max_fd = -1;
        FD_ZERO(&reactor->read_fds);
        return reactor;
    }

    void stopReactor(Reactor* reactor) {
        reactor->active = false;
    }

    void* reactorThread(void* arg) {
        Reactor* reactor = static_cast<Reactor*>(arg);
        std::unordered_map<int, handler_t> fd_to_handler;

        while (reactor->active) {
            fd_set tmp_fds = reactor->read_fds;
            int ret = select(reactor->max_fd + 1, &tmp_fds, nullptr, nullptr, nullptr);
            if (ret == -1) {
                perror("select");
                exit(1);
            }

            for (const auto& fd_handler : reactor->fds) {
                if (FD_ISSET(fd_handler.fd, &tmp_fds)) {
                    fd_to_handler[fd_handler.fd](fd_handler.fd);
                }
            }
        }
        pthread_exit(nullptr);
    }

    void addFdFunc(handler_t handler, int fd, Reactor* reactor) {
        FdHandler fdHandler = { fd, handler };
        reactor->fds.push_back(fdHandler);
        FD_SET(fd, &reactor->read_fds);
        if (fd > reactor->max_fd) {
            reactor->max_fd = fd;
        }
    }

    void startReactor(Reactor* reactor) {
        reactor->active = true;
        if (pthread_create(&reactor->thread, nullptr, reactorThread, reactor) != 0) {
            perror("pthread_create");
            exit(1);
        }
    }

    void waitFor(Reactor* reactor) {
        pthread_join(reactor->thread, nullptr);
    }
}
