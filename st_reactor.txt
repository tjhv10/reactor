#include <iostream>
#include <vector>
#include <unordered_map>
#include <functional>
#include <unistd.h>
#include <sys/select.h>
#include <pthread.h>

#define MAX_FDS 1024

using handler_t = std::function<void(int)>;

struct FdHandler {
    int fd;
    handler_t handler;
};

class Reactor {
public:
    Reactor() : active(false), max_fd(-1) {
        FD_ZERO(&read_fds);
    }

    void stopReactor() {
        active = false;
    }

    void startReactor() {
        active = true;
        if (pthread_create(&thread, nullptr, reactorThread, this) != 0) {
            perror("pthread_create");
            exit(1);
        }
    }

    void addFd(handler_t handler, int fd) {
        FdHandler fdHandler = { fd, handler };
        fds.push_back(fdHandler);
        FD_SET(fd, &read_fds);
        if (fd > max_fd) {
            max_fd = fd;
        }
    }

    void waitFor() {
        pthread_join(thread, nullptr);
    }

private:
    bool active;
    std::vector<FdHandler> fds;
    int max_fd;
    fd_set read_fds;
    pthread_t thread;

    static void* reactorThread(void* arg) {
        Reactor* reactor = static_cast<Reactor*>(arg);
        std::unordered_map<int, handler_t> fd_to_handler;

        while (reactor->active) {
            fd_set tmp_fds = reactor->read_fds;
            int ret = select(reactor->max_fd + 1, &tmp_fds, nullptr, nullptr, nullptr);
            if (ret == -1) {
                perror("select");
                exit(1);
            }

            for (const auto& fd_handler : reactor->fds) {
                if (FD_ISSET(fd_handler.fd, &tmp_fds)) {
                    fd_to_handler[fd_handler.fd](fd_handler.fd);
                }
            }
        }
        pthread_exit(nullptr);
    }
};

extern "C" {
    Reactor* createReactor() {
        return new Reactor();
    }
    void addFd(handler_t handler, int fd){
        Reactor().addFd(handler,fd);
    }
    void startReactor(){
        Reactor().startReactor();
    }
    void stopReactor(){
        Reactor().stopReactor();
    }
    void waitFor() {
        Reactor().waitFor();
    }
}
